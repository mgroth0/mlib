// Generated by CoffeeScript 2.5.1
//appendToBody(E.P('hola from signal_manscan.coffee'))
var DUR, RELOAD_THRESH, current_annos, current_arrow, ecg_plt, fixArrow, ibi_plt, increment, isShifting, last_message_id, newStart, newStop, pendingUpdate, pointer, pointerArrow, pointerL, requestedUpdate, shift, stopShifting, update, update_callback, windowRect, ws;

ecg_plt = function() {
  return plot_map[Object.keys(plot_map).find(function(e) {
    return e.includes('ECG');
  })];
};

ibi_plt = function() {
  return plot_map[Object.keys(plot_map).find(function(e) {
    return e.includes('IBI');
  })];
};

pendingUpdate = null;

requestedUpdate = false;

pointerArrow = function() {
  return {
    x: 0.5,
    y: 0.5,
    yanchor: 'middle',
    ax: 0,
    ay: -200,
    axref: 'paper',
    xref: 'paper',
    yref: 'paper',
    text: 'pointer',
    showarrow: true,
    arrowhead: 1
  };
};

last_message_id = 0;

current_annos = [];

ws = openSocketClient({
  url: "ws://localhost:9998",
  onopen: function() {
    this.send("GET_ALL");
    return log("Sent message GET_ALL...");
  },
  onmessage: function(evt) {
    var Y_FACTOR, a, arr, button, data, div, dv, i, len, template, u, xrange_down_button, xrange_up_button, yrange_down_button, yrange_up_button;
    data = JSON.parse(evt.data);
    log(`Message ${data.id} is received... (${evt.data.shorten(50)})`);
    if (last_message_id >= data.id) {
      log('    ... it was a duplicate');
      return;
    }
    last_message_id = data.id;
    if (data.type === 'TEXT') {
      return appendToBody(E.Pre(evt.data.afterFirst(':')));
    } else if (data.type === 'HTML' || data.type === 'PLOT') {
      div = E.Div(data.value);
      appendToBody(div);
      arr = div.getElementsByTagName('script');
      for (i = 0, len = arr.length; i < len; i++) {
        a = arr[i];
        eval(a.innerHTML); // run script inside div
      }
      if (data.type === 'PLOT') { //after ran script
        dv = div.children[0].children[0];
        dv = mplotly(dv);
        plot_map[dv._fullLayout.title.text] = dv;
        if (dv === ecg_plt()) {
          dv.def({
            x: function() {
              return this._fullData[0].x;
            },
            y: function() {
              return this._fullData[0].y;
            }
          });
          current_annos = ecg_plt()._fullLayout.annotations;
          Plotly.relayout(ecg_plt(), {
            'annotations': current_annos.concat([pointerArrow()])
          });
          Y_FACTOR = 5;
          yrange_down_button = E.button('y_range -');
          yrange_down_button.onclick = function() {
            return ecg_plt().animate({
              newYrange: ecg_plt()._fullLayout.yaxis.range.map(function(e) {
                return e / Y_FACTOR;
              })
            });
          };
          yrange_up_button = E.button('y_range +');
          yrange_up_button.onclick = function() {
            return ecg_plt().animate({
              newYrange: ecg_plt()._fullLayout.yaxis.range.map(function(e) {
                return e * Y_FACTOR;
              })
            });
          };
          div.appendChild(yrange_down_button);
          div.appendChild(yrange_up_button);
          xrange_down_button = E.button('x_range -');
          xrange_down_button.onclick = function() {
            var x_range;
            x_range = ecg_plt()._fullLayout.xaxis.range;
            if (x_range[1] - x_range[0] <= 2) {
              return;
            }
            x_range[0] += 1;
            x_range[1] -= 1;
            return ecg_plt().animate({
              newXrange: x_range
            });
          };
          xrange_up_button = E.button('x_range +');
          xrange_up_button.onclick = function() {
            var x_range;
            x_range = ecg_plt()._fullLayout.xaxis.range;
            if (x_range[1] - x_range[0] >= 10) {
              return;
            }
            x_range[0] -= 1;
            x_range[1] += 1;
            return ecg_plt().animate({
              newXrange: x_range
            });
          };
          div.appendChild(xrange_down_button);
          return div.appendChild(xrange_up_button);
        }
      }
    } else if (data.type === 'BUTTON') {
      template = document.createElement('template');
      template.innerHTML = data.html;
      button = template.content.firstChild;
      button.onclick = () => {
        var result;
        log(`clicked button ${name}`);
        result = JSON.stringify({
          name: button.innerHTML,
          state: {
            pointer: pointer
          }
        });
        return this.send(`BUTTON:${result}`);
      };
      return appendToBody(button);
    } else if (data.type === 'UPDATE') {
      requestedUpdate = false;
      u = JSON.parse(data.value);
      if (u != null) {
        if (isShifting) {
          return pendingUpdate = u;
        } else {
          return update(u);
        }
      }
    } else {
      //            err('unknown data type: ')
      return appendToBody(E.Div(data));
    }
  },
  onclose: function() {
    return alert("Connection is closed...");
  }
});

pointer = 0;

pointerL = null;

stopShifting = false;

isShifting = false;

increment = 1 / 100;

keydown(function(e) {
  var inc;
  if (e.keyCode === SPACE_BAR.keyCode) {
    return 1 + 1;
  } else if ([LEFT_ARROW.keyCode, RIGHT_ARROW.keyCode].includes(e.keyCode)) {
    if (!isShifting) {
      retic();
      log('finished retic');
      inc = 1;
      if (e.keyCode === LEFT_ARROW.keyCode) {
        inc = -1;
      }
      stopShifting = false;
      return shift(inc);
    }
  } else if ([UP_ARROW.keyCode, DOWN_ARROW.keyCode].includes(e.keyCode)) {
    if (e.keyCode === UP_ARROW.keyCode) {
      return increment *= 10;
    } else {
      return increment /= 10;
    }
  }
});

keyup(function(e) {
  if ([LEFT_ARROW.keyCode, RIGHT_ARROW.keyCode].includes(e.keyCode)) {
    return stopShifting = true;
  }
});

DUR = 10;

RELOAD_THRESH = 0.25;

windowRect = null;

update_callback = null;

newStart = null;

newStop = null;

current_arrow = null;

fixArrow = function({refresh} = {}) {
  var arrow, newPointer, newXrange, newYRange, newy, pointerLine, y;
  if (refresh == null) {
    refresh = false;
  }
  arrow = pointerArrow();
  arrow.yref = 'y';
  if (refresh || newStart === -1) { // happens after going really fast and updating
    //        setTimeout(->
    [newXrange, newYRange, newPointer, pointerLine, windowRect, newStart, newStop] = inc_calcs(ecg_plt(), 0);
  }
  //            fixArrow()
  //        , 3000)
  //        new Promise(->)
  //    else
  y = ecg_plt().y().slice(newStart, newStop); //bc at edges pointer is not at center
  newy = y[Math.round(y.length / 2)];
  //    log("setting new y to #{newy}")
  arrow.y = newy;
  //    ecg_plt().animate(
  //        newAnnotations: [arrow]
  //        dur         : 10
  //    )
  current_arrow = arrow;
  return Plotly.relayout(ecg_plt(), {
    'annotations': current_annos.concat([arrow])
  });
};

//fixArrow = log_invokation fixArrow
shift = function(pos) {
  var checkUp, inc, newPointer, newXrange, newYRange, pointerLine, update_check;
  isShifting = true;
  inc = increment * pos;
  log('about to call inc_calcs');
  [newXrange, newYRange, newPointer, pointerLine, windowRect, newStart, newStop] = inc_calcs(ecg_plt(), inc);
  log('finished inc_calcs');
  pointer = newPointer;
  pointerL = pointerLine;
  update_check = function({stack} = {}) {
    var dif, x, x0, xEnd;
    if (stack == null) {
      stack = false;
    }
    x = ecg_plt().x();
    x0 = x[0];
    xEnd = x.slice(-1)[0];
    dif = xEnd - x0;
    if ((pendingUpdate == null) && (!requestedUpdate) && (pointer > x0 + (dif * (.5 + RELOAD_THRESH)) || pointer < x0 + (dif * (.5 - RELOAD_THRESH)))) {
      ws.send(`GET_UPDATE:${pointer}`);
      return requestedUpdate = true;
    } else if (stack) {
      return update_callback = function() {
        ws.send(`GET_UPDATE:${pointer}`);
        return requestedUpdate = true;
      };
    }
  };
  update_check = log_invokation(update_check);
  checkUp = function() {
    if (stopShifting) {
      log('stopShifting!');
      //            fixArrow()
      update_check({
        stack: true
      });
      isShifting = false;
    }
    return fixArrow();
  };
  checkUp = log_invokation(checkUp);
  log('starting main shift');
  return ecg_plt().animate({
    //        data_changes: [[2, pointerLine]] #maybe
    newXrange: newXrange,
    //                    newYRange: newYRange\
    dur: DUR,
    redraw: false
  }).then(function(v) {
    log('finished main shift, checking if should update');
    update_check();
    return log('finished checking if should update');
  }).then(function(v) {
    log('in next then (why another?)');
    if (pendingUpdate != null) {
      return update(pendingUpdate);
    }
  }).then(function(v) {
    log('in final then');
    return checkUp().then(function() {
      if (!stopShifting) {
        return shift(pos);
      }
    });
  }).catch(checkUp);
};

shift = log_invokation(shift);

update = function(u) {
  var data, the_update;
  //            ibi_plt has nothing to do with pending update. Its just that it doesnt need to update that often, so this is a way to save resources and its roughly the update frequency that I want
  data = u.data;
  current_annos = u.annotations;
  ibi_plt().animate({
    data_changes: [[1, windowRect]]
  });
  the_update = {
    data_changes: [[0, data[0]], [1, data[1]], [2, data[2]]],
    newAnnotations: current_annos.concat([current_arrow]),
    dur: 1
  };
  if (u.yrange != null) {
    the_update = merge(the_update, {
      newYrange: u.yrange
    });
  }
  return ecg_plt().animate(the_update).then(function(v) {
    fixArrow({
      refresh: true
    });
    pendingUpdate = null;
    if (update_callback != null) {
      update_callback();
      return update_callback = null;
    }
  }).catch(function(r) {
    fixArrow({
      refresh: true
    });
    pendingUpdate = null;
    if (update_callback != null) {
      update_callback();
      return update_callback = null;
    }
  });
};

update = log_invokation(update);

//# sourceMappingURL=signal_manscan.js.map
